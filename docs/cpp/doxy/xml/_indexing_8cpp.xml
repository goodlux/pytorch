<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="_indexing_8cpp" kind="file" language="C++">
    <compoundname>Indexing.cpp</compoundname>
    <includes refid="_a_ten_8h" local="yes">ATen/ATen.h</includes>
    <includes local="yes">ATen/NativeFunctions.h</includes>
    <includes refid="_expand_utils_8h" local="yes">ATen/ExpandUtils.h</includes>
    <includes local="no">algorithm</includes>
    <includes local="no">functional</includes>
    <includes local="no">numeric</includes>
    <includes local="no">vector</includes>
    <incdepgraph>
      <node id="6309">
        <label>ATen/optional.h</label>
        <link refid="optional_8h_source"/>
        <childnode refid="6310" relation="include">
        </childnode>
        <childnode refid="6311" relation="include">
        </childnode>
        <childnode refid="6312" relation="include">
        </childnode>
        <childnode refid="6313" relation="include">
        </childnode>
        <childnode refid="6314" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6316" relation="include">
        </childnode>
      </node>
      <node id="6355">
        <label>ATen/detail/CUDAHooksInterface.h</label>
        <link refid="_c_u_d_a_hooks_interface_8h_source"/>
        <childnode refid="6305" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6353" relation="include">
        </childnode>
        <childnode refid="6356" relation="include">
        </childnode>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6314" relation="include">
        </childnode>
        <childnode refid="6306" relation="include">
        </childnode>
      </node>
      <node id="6323">
        <label>ATen/Device.h</label>
        <link refid="_device_8h_source"/>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6339" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6314" relation="include">
        </childnode>
      </node>
      <node id="6322">
        <label>atomic</label>
      </node>
      <node id="6314">
        <label>functional</label>
      </node>
      <node id="6360">
        <label>ATen/Backtrace.h</label>
        <link refid="_backtrace_8h_source"/>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6350" relation="include">
        </childnode>
        <childnode refid="6303" relation="include">
        </childnode>
      </node>
      <node id="6324">
        <label>ATen/ScalarType.h</label>
        <link refid="_scalar_type_8h_source"/>
        <childnode refid="6325" relation="include">
        </childnode>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6335" relation="include">
        </childnode>
        <childnode refid="6337" relation="include">
        </childnode>
        <childnode refid="6341" relation="include">
        </childnode>
      </node>
      <node id="6336">
        <label>limits</label>
      </node>
      <node id="6344">
        <label>assert.h</label>
      </node>
      <node id="6349">
        <label>ATen/Utils.h</label>
        <link refid="aten_2src_2_a_ten_2utils_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6325" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6348" relation="include">
        </childnode>
        <childnode refid="6328" relation="include">
        </childnode>
        <childnode refid="6320" relation="include">
        </childnode>
        <childnode refid="6350" relation="include">
        </childnode>
        <childnode refid="6351" relation="include">
        </childnode>
      </node>
      <node id="6331">
        <label>iterator</label>
      </node>
      <node id="6343">
        <label>ATen/Scalar.h</label>
        <link refid="_scalar_8h_source"/>
        <childnode refid="6344" relation="include">
        </childnode>
        <childnode refid="6345" relation="include">
        </childnode>
        <childnode refid="6316" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6310" relation="include">
        </childnode>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6335" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6346" relation="include">
        </childnode>
        <childnode refid="6349" relation="include">
        </childnode>
      </node>
      <node id="6363">
        <label>TH/THStorageFunctions.hpp</label>
      </node>
      <node id="6337">
        <label>cstdint</label>
      </node>
      <node id="6371">
        <label>ATen/Deprecated.h</label>
        <link refid="_deprecated_8h_source"/>
      </node>
      <node id="6345">
        <label>stdint.h</label>
      </node>
      <node id="6382">
        <label>ATen/CUDAGuard.h</label>
        <link refid="_c_u_d_a_guard_8h_source"/>
      </node>
      <node id="6338">
        <label>cmath</label>
      </node>
      <node id="6313">
        <label>cassert</label>
      </node>
      <node id="6354">
        <label>ATen/Context.h</label>
        <link refid="_context_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6304" relation="include">
        </childnode>
        <childnode refid="6353" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6349" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6355" relation="include">
        </childnode>
        <childnode refid="6361" relation="include">
        </childnode>
        <childnode refid="6306" relation="include">
        </childnode>
        <childnode refid="6358" relation="include">
        </childnode>
        <childnode refid="6337" relation="include">
        </childnode>
      </node>
      <node id="6340">
        <label>Half-inl.h</label>
        <link refid="_half-inl_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6330" relation="include">
        </childnode>
        <childnode refid="6336" relation="include">
        </childnode>
      </node>
      <node id="6316">
        <label>stdexcept</label>
      </node>
      <node id="6377">
        <label>ATen/TensorOperators.h</label>
        <link refid="_tensor_operators_8h_source"/>
        <childnode refid="6343" relation="include">
        </childnode>
        <childnode refid="6364" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6316" relation="include">
        </childnode>
      </node>
      <node id="6351">
        <label>numeric</label>
      </node>
      <node id="6347">
        <label>ATen/TensorImpl.h</label>
        <link refid="_tensor_impl_8h_source"/>
        <childnode refid="6322" relation="include">
        </childnode>
        <childnode refid="6306" relation="include">
        </childnode>
        <childnode refid="6321" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6309" relation="include">
        </childnode>
      </node>
      <node id="6335">
        <label>ATen/Half.h</label>
        <link refid="_half_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6336" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6337" relation="include">
        </childnode>
        <childnode refid="6316" relation="include">
        </childnode>
        <childnode refid="6310" relation="include">
        </childnode>
        <childnode refid="6338" relation="include">
        </childnode>
        <childnode refid="6339" relation="include">
        </childnode>
        <childnode refid="6340" relation="include">
        </childnode>
      </node>
      <node id="6321">
        <label>ATen/Retainable.h</label>
        <link refid="_retainable_8h_source"/>
        <childnode refid="6322" relation="include">
        </childnode>
      </node>
      <node id="6346">
        <label>ATen/TensorBase.h</label>
        <link refid="_tensor_base_8h_source"/>
        <childnode refid="6347" relation="include">
        </childnode>
        <childnode refid="6348" relation="include">
        </childnode>
      </node>
      <node id="6315">
        <label>string</label>
      </node>
      <node id="6380">
        <label>ATen/DimVector.h</label>
        <link refid="_dim_vector_8h_source"/>
        <childnode refid="6326" relation="include">
        </childnode>
        <childnode refid="6345" relation="include">
        </childnode>
      </node>
      <node id="6381">
        <label>ATen/OptionsGuard.h</label>
        <link refid="_options_guard_8h_source"/>
        <childnode refid="6323" relation="include">
        </childnode>
        <childnode refid="6367" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6374" relation="include">
        </childnode>
        <childnode refid="6309" relation="include">
        </childnode>
      </node>
      <node id="6383">
        <label>ATen/ExpandUtils.h</label>
        <link refid="_expand_utils_8h_source"/>
        <childnode refid="6364" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6314" relation="include">
        </childnode>
        <childnode refid="6320" relation="include">
        </childnode>
        <childnode refid="6384" relation="include">
        </childnode>
      </node>
      <node id="6305">
        <label>ATen/Allocator.h</label>
        <link refid="_allocator_8h_source"/>
        <childnode refid="6306" relation="include">
        </childnode>
        <childnode refid="6307" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6321" relation="include">
        </childnode>
        <childnode refid="6323" relation="include">
        </childnode>
        <childnode refid="6342" relation="include">
        </childnode>
      </node>
      <node id="6361">
        <label>ATen/CUDAStream.h</label>
        <link refid="_c_u_d_a_stream_8h_source"/>
      </node>
      <node id="6373">
        <label>ATen/DeviceGuard.h</label>
        <link refid="_device_guard_8h_source"/>
        <childnode refid="6323" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6364" relation="include">
        </childnode>
        <childnode refid="6355" relation="include">
        </childnode>
        <childnode refid="6317" relation="include">
        </childnode>
      </node>
      <node id="6318">
        <label>exception</label>
      </node>
      <node id="6307">
        <label>stddef.h</label>
      </node>
      <node id="6348">
        <label>ATen/UndefinedTensor.h</label>
        <link refid="_undefined_tensor_8h_source"/>
        <childnode refid="6347" relation="include">
        </childnode>
      </node>
      <node id="6379">
        <label>ATen/Dispatch.h</label>
        <link refid="_dispatch_8h_source"/>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6335" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
      </node>
      <node id="6327">
        <label>AlignOf.h</label>
        <link refid="_align_of_8h_source"/>
        <childnode refid="6317" relation="include">
        </childnode>
      </node>
      <node id="6362">
        <label>ATen/Storage.h</label>
        <link refid="_storage_8h_source"/>
        <childnode refid="6343" relation="include">
        </childnode>
        <childnode refid="6363" relation="include">
        </childnode>
      </node>
      <node id="6319">
        <label>ostream</label>
      </node>
      <node id="6304">
        <label>ATen/CPUGeneral.h</label>
        <link refid="_c_p_u_general_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
      </node>
      <node id="6352">
        <label>ATen/Type.h</label>
      </node>
      <node id="6301">
        <label>/Users/robkunkle/fork/goodlux/pytorch/aten/src/ATen/native/Indexing.cpp</label>
        <link refid="_indexing_8cpp"/>
        <childnode refid="6302" relation="include">
        </childnode>
        <childnode refid="6372" relation="include">
        </childnode>
        <childnode refid="6383" relation="include">
        </childnode>
        <childnode refid="6328" relation="include">
        </childnode>
        <childnode refid="6314" relation="include">
        </childnode>
        <childnode refid="6351" relation="include">
        </childnode>
        <childnode refid="6334" relation="include">
        </childnode>
      </node>
      <node id="6325">
        <label>ATen/ArrayRef.h</label>
        <link refid="_array_ref_8h_source"/>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6326" relation="include">
        </childnode>
        <childnode refid="6333" relation="include">
        </childnode>
        <childnode refid="6331" relation="include">
        </childnode>
        <childnode refid="6334" relation="include">
        </childnode>
      </node>
      <node id="6368">
        <label>ATen/TensorGeometry.h</label>
        <link refid="_tensor_geometry_8h_source"/>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6369" relation="include">
        </childnode>
      </node>
      <node id="6365">
        <label>ATen/SparseTensorRef.h</label>
        <link refid="_sparse_tensor_ref_8h_source"/>
      </node>
      <node id="6303">
        <label>ATen/ATenGeneral.h</label>
        <link refid="_a_ten_general_8h_source"/>
      </node>
      <node id="6369">
        <label>ATen/WrapDimUtils.h</label>
        <link refid="_wrap_dim_utils_8h_source"/>
        <childnode refid="6347" relation="include">
        </childnode>
        <childnode refid="6320" relation="include">
        </childnode>
      </node>
      <node id="6366">
        <label>ATen/TensorAccessor.h</label>
        <link refid="_tensor_accessor_8h_source"/>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6345" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
      </node>
      <node id="6350">
        <label>typeinfo</label>
      </node>
      <node id="6357">
        <label>cstdio</label>
      </node>
      <node id="6384">
        <label>tuple</label>
      </node>
      <node id="6342">
        <label>ATen/detail/UniqueVoidPtr.h</label>
        <link refid="_unique_void_ptr_8h_source"/>
        <childnode refid="6306" relation="include">
        </childnode>
        <childnode refid="6303" relation="include">
        </childnode>
      </node>
      <node id="6334">
        <label>vector</label>
      </node>
      <node id="6378">
        <label>ATen/TensorMethods.h</label>
      </node>
      <node id="6375">
        <label>THNN/Reduction.h</label>
      </node>
      <node id="6332">
        <label>new</label>
      </node>
      <node id="6310">
        <label>utility</label>
      </node>
      <node id="6333">
        <label>array</label>
      </node>
      <node id="6320">
        <label>sstream</label>
      </node>
      <node id="6370">
        <label>ATen/Functions.h</label>
        <link refid="build_2aten_2src_2_a_ten_2_functions_8h_source"/>
        <childnode refid="6343" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6364" relation="include">
        </childnode>
        <childnode refid="6362" relation="include">
        </childnode>
        <childnode refid="6353" relation="include">
        </childnode>
        <childnode refid="6371" relation="include">
        </childnode>
        <childnode refid="6372" relation="include">
        </childnode>
        <childnode refid="6373" relation="include">
        </childnode>
        <childnode refid="6374" relation="include">
        </childnode>
        <childnode refid="6375" relation="include">
        </childnode>
      </node>
      <node id="6372">
        <label>ATen/NativeFunctions.h</label>
      </node>
      <node id="6339">
        <label>iosfwd</label>
      </node>
      <node id="6329">
        <label>cstdlib</label>
      </node>
      <node id="6341">
        <label>iostream</label>
      </node>
      <node id="6317">
        <label>cstddef</label>
      </node>
      <node id="6359">
        <label>unordered_map</label>
      </node>
      <node id="6358">
        <label>mutex</label>
      </node>
      <node id="6302">
        <label>ATen/ATen.h</label>
        <link refid="_a_ten_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6304" relation="include">
        </childnode>
        <childnode refid="6305" relation="include">
        </childnode>
        <childnode refid="6343" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6353" relation="include">
        </childnode>
        <childnode refid="6354" relation="include">
        </childnode>
        <childnode refid="6362" relation="include">
        </childnode>
        <childnode refid="6364" relation="include">
        </childnode>
        <childnode refid="6323" relation="include">
        </childnode>
        <childnode refid="6368" relation="include">
        </childnode>
        <childnode refid="6370" relation="include">
        </childnode>
        <childnode refid="6376" relation="include">
        </childnode>
        <childnode refid="6377" relation="include">
        </childnode>
        <childnode refid="6378" relation="include">
        </childnode>
        <childnode refid="6379" relation="include">
        </childnode>
        <childnode refid="6380" relation="include">
        </childnode>
        <childnode refid="6373" relation="include">
        </childnode>
        <childnode refid="6374" relation="include">
        </childnode>
        <childnode refid="6367" relation="include">
        </childnode>
        <childnode refid="6381" relation="include">
        </childnode>
        <childnode refid="6382" relation="include">
        </childnode>
      </node>
      <node id="6356">
        <label>ATen/Registry.h</label>
        <link refid="_registry_8h_source"/>
        <childnode refid="6328" relation="include">
        </childnode>
        <childnode refid="6357" relation="include">
        </childnode>
        <childnode refid="6329" relation="include">
        </childnode>
        <childnode refid="6314" relation="include">
        </childnode>
        <childnode refid="6306" relation="include">
        </childnode>
        <childnode refid="6358" relation="include">
        </childnode>
        <childnode refid="6359" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
        <childnode refid="6334" relation="include">
        </childnode>
        <childnode refid="6360" relation="include">
        </childnode>
        <childnode refid="6303" relation="include">
        </childnode>
      </node>
      <node id="6308">
        <label>ATen/Error.h</label>
        <link refid="_error_8h_source"/>
        <childnode refid="6303" relation="include">
        </childnode>
        <childnode refid="6309" relation="include">
        </childnode>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6318" relation="include">
        </childnode>
        <childnode refid="6319" relation="include">
        </childnode>
        <childnode refid="6320" relation="include">
        </childnode>
        <childnode refid="6315" relation="include">
        </childnode>
      </node>
      <node id="6374">
        <label>ATen/TensorOptions.h</label>
        <link refid="_tensor_options_8h_source"/>
        <childnode refid="6354" relation="include">
        </childnode>
        <childnode refid="6323" relation="include">
        </childnode>
        <childnode refid="6373" relation="include">
        </childnode>
        <childnode refid="6367" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6364" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6339" relation="include">
        </childnode>
        <childnode refid="6310" relation="include">
        </childnode>
      </node>
      <node id="6364">
        <label>ATen/Tensor.h</label>
        <link refid="build_2aten_2src_2_a_ten_2tensor_8h_source"/>
        <childnode refid="6353" relation="include">
        </childnode>
        <childnode refid="6343" relation="include">
        </childnode>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6365" relation="include">
        </childnode>
        <childnode refid="6362" relation="include">
        </childnode>
        <childnode refid="6366" relation="include">
        </childnode>
        <childnode refid="6346" relation="include">
        </childnode>
        <childnode refid="6347" relation="include">
        </childnode>
        <childnode refid="6349" relation="include">
        </childnode>
        <childnode refid="6323" relation="include">
        </childnode>
        <childnode refid="6367" relation="include">
        </childnode>
        <childnode refid="6309" relation="include">
        </childnode>
      </node>
      <node id="6311">
        <label>type_traits</label>
      </node>
      <node id="6367">
        <label>ATen/Layout.h</label>
        <link refid="_layout_8h_source"/>
        <childnode refid="6324" relation="include">
        </childnode>
        <childnode refid="6308" relation="include">
        </childnode>
        <childnode refid="6341" relation="include">
        </childnode>
      </node>
      <node id="6326">
        <label>ATen/SmallVector.h</label>
        <link refid="_small_vector_8h_source"/>
        <childnode refid="6327" relation="include">
        </childnode>
        <childnode refid="6328" relation="include">
        </childnode>
        <childnode refid="6313" relation="include">
        </childnode>
        <childnode refid="6317" relation="include">
        </childnode>
        <childnode refid="6329" relation="include">
        </childnode>
        <childnode refid="6330" relation="include">
        </childnode>
        <childnode refid="6312" relation="include">
        </childnode>
        <childnode refid="6331" relation="include">
        </childnode>
        <childnode refid="6306" relation="include">
        </childnode>
        <childnode refid="6332" relation="include">
        </childnode>
        <childnode refid="6311" relation="include">
        </childnode>
        <childnode refid="6310" relation="include">
        </childnode>
        <childnode refid="6303" relation="include">
        </childnode>
      </node>
      <node id="6328">
        <label>algorithm</label>
      </node>
      <node id="6353">
        <label>ATen/Generator.h</label>
        <link refid="_generator_8h_source"/>
        <childnode refid="6345" relation="include">
        </childnode>
      </node>
      <node id="6330">
        <label>cstring</label>
      </node>
      <node id="6306">
        <label>memory</label>
      </node>
      <node id="6312">
        <label>initializer_list</label>
      </node>
      <node id="6376">
        <label>ATen/Formatting.h</label>
        <link refid="_formatting_8h_source"/>
        <childnode refid="6341" relation="include">
        </childnode>
        <childnode refid="6352" relation="include">
        </childnode>
        <childnode refid="6343" relation="include">
        </childnode>
      </node>
    </incdepgraph>
    <innernamespace refid="namespaceat">at</innernamespace>
    <innernamespace refid="namespaceat_1_1native">at::native</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">//<sp/>Indexing<sp/>tensors<sp/>by<sp/>by<sp/>tensors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>corresponds<sp/>to<sp/>&quot;advanced<sp/>indexing&quot;<sp/>in<sp/>NumPy.<sp/>The<sp/>two<sp/>operations<sp/>are:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>index(Tensor<sp/>self,<sp/>indices)<sp/>-&gt;<sp/>Tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>index_put_(Tensor<sp/>self,<sp/>indices,<sp/>value)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>index<sp/>is<sp/>a<sp/>TensorList<sp/>containg<sp/>kLong<sp/>or<sp/>kByte<sp/>tensors<sp/>or<sp/>nulls.<sp/>Byte</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="comment">//<sp/>tensors<sp/>(boolean<sp/>masks)<sp/>are<sp/>expanded<sp/>to<sp/>long<sp/>tensors<sp/>via<sp/>nonzero().<sp/>Null</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="comment">//<sp/>tensors<sp/>signify<sp/>that<sp/>the<sp/>dimension<sp/>is<sp/>not<sp/>indexed.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="comment">//<sp/>All<sp/>indexes<sp/>are<sp/>broadcast<sp/>together<sp/>and<sp/>iterated<sp/>as<sp/>*one*.<sp/>From<sp/>NumPy:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="comment">//<sp/>result[i_1,<sp/>...,<sp/>i_M]<sp/>==<sp/>x[ind_1[i_1,<sp/>...,<sp/>i_M],<sp/>ind_2[i_1,<sp/>...,<sp/>i_M],</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...,<sp/>ind_N[i_1,<sp/>...,<sp/>i_M]]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>1:<sp/>ByteTensors<sp/>expand<sp/>to<sp/>index<sp/>as<sp/>many<sp/>dimensions<sp/>as<sp/>there<sp/>are<sp/>in<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="comment">//<sp/>mask.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Note<sp/>2:<sp/>The<sp/>behavior<sp/>is<sp/>more<sp/>complicated<sp/>when<sp/>the<sp/>index<sp/>tensors<sp/>are<sp/>not<sp/>all</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="comment">//<sp/>adjacent<sp/>(e.g.<sp/>x[[0,<sp/>1],<sp/>:,<sp/>[2,<sp/>3]]).<sp/>In<sp/>this<sp/>case,<sp/>self<sp/>and<sp/>the<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="comment">//<sp/>tensors<sp/>are<sp/>transposed<sp/>to<sp/>the<sp/>front:<sp/>x.transpose(1,<sp/>2)[[0,<sp/>1],<sp/>[2,<sp/>3]]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ATen/ATen.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ATen/NativeFunctions.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ATen/ExpandUtils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;functional&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;numeric&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceat" kindref="compound">at</ref><sp/>{<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">native<sp/>{</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal">[[noreturn]]</highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>invalid_mask(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>int64_t<sp/>idx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>mask,<sp/>int64_t<sp/>maskIdx)<sp/>{</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/>std::stringstream<sp/>ss;</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/>ss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>shape<sp/>of<sp/>the<sp/>mask<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>mask.sizes()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>index<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>maskIdx;</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/>ss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>does<sp/>not<sp/>match<sp/>the<sp/>shape<sp/>of<sp/>the<sp/>indexed<sp/>tensor<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.sizes();</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/>ss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>index<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>idx;</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(ss.str());</highlight></codeline>
<codeline lineno="43"><highlight class="normal">}</highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>checkIndexTensorTypes(TensorList<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>tensor<sp/>:<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tensor.defined())<sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>type<sp/>=<sp/>tensor.type();</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>scalarType<sp/>=<sp/>type.scalarType();</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(scalarType<sp/>!=<sp/>kLong<sp/>&amp;&amp;<sp/>scalarType<sp/>!=<sp/>kByte)<sp/>{</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight><highlight class="stringliteral">&quot;tensors<sp/>used<sp/>as<sp/>indices<sp/>must<sp/>be<sp/>long<sp/>or<sp/>byte<sp/>tensors&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="55"><highlight class="normal">}</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>std::vector&lt;Tensor&gt;<sp/>expandByteTensors(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>TensorList<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Expands<sp/>byte<sp/>tensors<sp/>(masks)<sp/>into<sp/>the<sp/>equivalent<sp/>indexing<sp/>by<sp/>LongTensors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/>std::vector&lt;Tensor&gt;<sp/>result;</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;<sp/>index<sp/>:<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index.type().scalarType()<sp/>==<sp/>kByte)<sp/>{</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>sizes<sp/>of<sp/>the<sp/>ByteTensor<sp/>mask<sp/>must<sp/>match<sp/>the<sp/>sizes<sp/>of<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>corresponding<sp/>dimensions<sp/>in<sp/>self</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>index.dim();<sp/>j++)<sp/>{</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>srcIdx<sp/>=<sp/>result.size()<sp/>+<sp/>j;</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index.size(j)<sp/>!=<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.size(srcIdx))<sp/>{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>invalid_mask(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>srcIdx,<sp/>index,<sp/>j);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Replace<sp/>with<sp/>nonzeros</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>nonzero<sp/>=<sp/>index.nonzero();</highlight></codeline>
<codeline lineno="72"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>USE_TH_SIZE_ZERO_DIM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>special_empty<sp/>=<sp/>nonzero.numel()<sp/>==<sp/>0;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>special_empty<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>index.dim();<sp/>j++)<sp/>{</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(special_empty)<sp/>{</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>can&apos;t<sp/>call<sp/>select<sp/>on<sp/>an<sp/>empty<sp/>tensor<sp/>so<sp/>we<sp/>just<sp/>create<sp/>an<sp/>empty</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>tensor.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result.emplace_back(nonzero.type().tensor());</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result.emplace_back(nonzero.select(1,<sp/>j));</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result.emplace_back(index);</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="91"><highlight class="normal">}</highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>hasContiguousSubspace(TensorList<sp/>tl)<sp/>{</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>true<sp/>if<sp/>all<sp/>the<sp/>non-null<sp/>tensors<sp/>are<sp/>adjacent</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>isDefined<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>tensor){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>tensor.defined();<sp/>};</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>isNull<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>tensor){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!tensor.defined();<sp/>};</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>start<sp/>=<sp/>std::find_if(tl.begin(),<sp/>tl.end(),<sp/>isDefined);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>stop<sp/>=<sp/>std::find_if(tl.rbegin(),<sp/>tl.rend(),<sp/>isDefined);</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>std::find_if(start,<sp/>stop.base(),<sp/>isNull);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>it<sp/>==<sp/>stop.base();</highlight></codeline>
<codeline lineno="101"><highlight class="normal">}</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Transposes<sp/>the<sp/>tensor<sp/>and<sp/>indices<sp/>together<sp/>so<sp/>that<sp/>all<sp/>the<sp/>non-null<sp/>indices</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight><highlight class="comment">//<sp/>index<sp/>the<sp/>first<sp/>k<sp/>dimensions<sp/>of<sp/>the<sp/>tensor.<sp/>Returns<sp/>the<sp/>transposed<sp/>tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight><highlight class="comment">//<sp/>and<sp/>the<sp/>reordered<sp/>indices.<sp/>For<sp/>example:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>transposeToFront(tensor,<sp/>{nullptr,<sp/>a,<sp/>nullptr,<sp/>b})</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight><highlight class="comment">//<sp/>returns</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/>tensor.permute([1,<sp/>3,<sp/>0,<sp/>2]),<sp/>{a,<sp/>b,<sp/>nullptr,<sp/>nullptr}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>std::tuple&lt;Tensor,<sp/>std::vector&lt;Tensor&gt;&gt;</highlight></codeline>
<codeline lineno="110"><highlight class="normal">transposeToFront(Tensor<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>TensorList<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/>std::vector&lt;int64_t&gt;<sp/>dims;</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/>std::vector&lt;Tensor&gt;<sp/>transposedIndices;</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/>dims.reserve(</highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim());</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim();<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(indices[i].defined())<sp/>{</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dims.push_back(i);</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>transposedIndices.emplace_back(indices[i]);</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim();<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!indices[i].defined())<sp/>{</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dims.push_back(i);</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>transposedIndices.emplace_back();</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_tuple(</highlight><highlight class="keyword">self</highlight><highlight class="normal">.permute(dims),<sp/>std::move(transposedIndices));</highlight></codeline>
<codeline lineno="127"><highlight class="normal">}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>std::vector&lt;int64_t&gt;<sp/>computeLinearStride(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>tensor)<sp/>{</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>computes<sp/>the<sp/>stride<sp/>as<sp/>if<sp/>tensor<sp/>were<sp/>contigous</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sizes<sp/>=<sp/>tensor.sizes();</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/>std::vector&lt;int64_t&gt;<sp/>stride(tensor.dim());</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/>stride[tensor.dim()<sp/>-<sp/>1]<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/>std::partial_sum(sizes.rbegin(),<sp/>sizes.rend()<sp/>-<sp/>1,<sp/>stride.rbegin()<sp/>+<sp/>1,<sp/>std::multiplies&lt;int64_t&gt;());</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>stride;</highlight></codeline>
<codeline lineno="136"><highlight class="normal">}</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Unsqueezes<sp/>src<sp/>`before`<sp/>times<sp/>at<sp/>the<sp/>front<sp/>and<sp/>`after`<sp/>times<sp/>at<sp/>the<sp/>end</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>Tensor<sp/>unsqueezeN(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>src,<sp/>int64_t<sp/>before,<sp/>int64_t<sp/>after)<sp/>{</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>srcSizes<sp/>=<sp/>src.sizes();</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>nDim<sp/>=<sp/>src.dim();</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/>std::vector&lt;int64_t&gt;<sp/>sizes(nDim<sp/>+<sp/>before<sp/>+<sp/>after,<sp/>1);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>nDim;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/>sizes[i<sp/>+<sp/>before]<sp/>=<sp/>srcSizes[i];</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>src.view(sizes);</highlight></codeline>
<codeline lineno="147"><highlight class="normal">}</highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>Tensor<sp/>wrapIndexOnce(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>index,<sp/>int64_t<sp/>dim,<sp/>int64_t<sp/>dim_size)<sp/>{</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index.numel()<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>max_idx<sp/>=<sp/>index.max().toCLong();</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>min_idx<sp/>=<sp/>index.min().toCLong();</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(max_idx<sp/>&gt;=<sp/>dim_size)<sp/>{</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>AT_ERROR(</highlight><highlight class="stringliteral">&quot;index<sp/>&quot;</highlight><highlight class="normal">,<sp/>max_idx,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>out<sp/>of<sp/>bounds<sp/>for<sp/>dimension<sp/>&quot;</highlight><highlight class="normal">,<sp/>dim,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>with<sp/>size<sp/>&quot;</highlight><highlight class="normal">,<sp/>dim_size);</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(min_idx<sp/>&lt;<sp/>-dim_size)<sp/>{</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>AT_ERROR(</highlight><highlight class="stringliteral">&quot;index<sp/>&quot;</highlight><highlight class="normal">,<sp/>min_idx,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>out<sp/>of<sp/>bounds<sp/>for<sp/>dimension<sp/>&quot;</highlight><highlight class="normal">,<sp/>dim,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>with<sp/>size<sp/>&quot;</highlight><highlight class="normal">,<sp/>dim_size);</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>index.remainder(dim_size);</highlight></codeline>
<codeline lineno="161"><highlight class="normal">}</highlight></codeline>
<codeline lineno="162"><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>Tensor<sp/>computeLinearIndex(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>src,<sp/>TensorList<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>strides<sp/>=<sp/>computeLinearStride(src);</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/>Type&amp;<sp/>longType<sp/>=<sp/>src.type().toScalarType(kLong);</highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>linear<sp/>index<sp/>by<sp/>multiplying<sp/>the<sp/>indexing<sp/>tensors<sp/>by<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>stride<sp/>and<sp/>summing<sp/>them.<sp/>All<sp/>the<sp/>indexing<sp/>tensors<sp/>have<sp/>the<sp/>same<sp/>shape<sp/>at</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>point.<sp/>We<sp/>also<sp/>compute<sp/>the<sp/>number<sp/>of<sp/>dimensions<sp/>before<sp/>and<sp/>after<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>are<sp/>not<sp/>being<sp/>index.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/>Tensor<sp/>linearIndex;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/>int64_t<sp/>emptyBefore<sp/>=<sp/>0,<sp/>emptyAfter<sp/>=<sp/>0,<sp/>nElemBefore<sp/>=<sp/>1,<sp/>nElemAfter<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>src.dim();<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(indices[i].defined())<sp/>{</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>index<sp/>to<sp/>the<sp/>longType<sp/>matching<sp/>src&apos;s<sp/>backend</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>allows<sp/>us<sp/>to<sp/>support<sp/>ie<sp/>indexing<sp/>a<sp/>cuda<sp/>tensor<sp/>with<sp/>a<sp/>cpu<sp/>tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Tensor<sp/>index<sp/>=<sp/>(wrapIndexOnce(indices[i],<sp/>i,<sp/>src.size(i))<sp/>*<sp/>strides[i]).toType(longType);</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(linearIndex.defined())<sp/>{</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>linearIndex<sp/>+=<sp/>index;</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>linearIndex<sp/>=<sp/>index;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(linearIndex.defined())<sp/>{</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>emptyAfter++;</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nElemAfter<sp/>*=<sp/>src.size(i);</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>emptyBefore++;</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>nElemBefore<sp/>*=<sp/>src.size(i);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="191"><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>linear<sp/>indices<sp/>for<sp/>the<sp/>parts<sp/>of<sp/>the<sp/>tensor<sp/>not<sp/>being<sp/>indexed</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/>Tensor<sp/>beforeIndex;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(emptyBefore<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>at::arange(0,<sp/>nElemBefore,<sp/>longType)<sp/>*<sp/>strides[emptyBefore<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>=<sp/>index.view(src.sizes().slice(0,<sp/>emptyBefore));</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/>beforeIndex<sp/>=<sp/>unsqueezeN(index,<sp/>0,<sp/>linearIndex.dim()<sp/>+<sp/>emptyAfter);</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/>Tensor<sp/>afterIndex;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(emptyAfter<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>at::arange(0,<sp/>nElemAfter,<sp/>longType);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>=<sp/>index.view(src.sizes().slice(src.dim()<sp/>-<sp/>emptyAfter,<sp/>emptyAfter));</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/>afterIndex<sp/>=<sp/>unsqueezeN(index,<sp/>linearIndex.dim()<sp/>+<sp/>emptyBefore,<sp/>0);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Sum<sp/>with<sp/>broadcasting<sp/>to<sp/>compute<sp/>the<sp/>full<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/>linearIndex<sp/>=<sp/>unsqueezeN(linearIndex,<sp/>emptyBefore,<sp/>emptyAfter);</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(beforeIndex.defined())<sp/>{</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/>linearIndex<sp/>=<sp/>linearIndex<sp/>+<sp/>beforeIndex;</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(afterIndex.defined())<sp/>{</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/>linearIndex<sp/>=<sp/>linearIndex<sp/>+<sp/>afterIndex;</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>linearIndex;</highlight></codeline>
<codeline lineno="215"><highlight class="normal">}</highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>USE_TH_SIZE_ZERO_DIM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>hasEmptyTensor(TensorList<sp/>tensors)<sp/>{</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>tensor<sp/>:<sp/>tensors)<sp/>{</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tensor.defined()<sp/>&amp;&amp;<sp/>tensor.numel()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="225"><highlight class="normal">}</highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>std::tuple&lt;Tensor,<sp/>Tensor&gt;<sp/>makeLinearIndex(Tensor<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>TensorList<sp/>orig)<sp/>{</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/>checkIndexTensorTypes(orig);</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>first<sp/>expand<sp/>ByteTensor<sp/>(boolean<sp/>masks)<sp/>into<sp/>1<sp/>or<sp/>more<sp/>LongTensors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>indices<sp/>=<sp/>expandByteTensors(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>orig);</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>USE_TH_SIZE_ZERO_DIM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(hasEmptyTensor(indices))<sp/>{</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_tuple(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.type().toScalarType(kLong).tensor());</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>next<sp/>broadcast<sp/>all<sp/>index<sp/>tensors<sp/>together</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/>indices<sp/>=<sp/>expand_outplace(indices);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>missing<sp/>null<sp/>Tensors<sp/>so<sp/>that<sp/>it<sp/>matches<sp/>self.dim()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(indices.size()<sp/>&lt;<sp/>(size_t)</highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim())<sp/>{</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>indices.emplace_back();</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>the<sp/>non-null<sp/>indices<sp/>are<sp/>not<sp/>all<sp/>adjacent,<sp/>transpose<sp/>self<sp/>and<sp/>indices</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>together<sp/>so<sp/>that<sp/>they&apos;re<sp/>adjacent<sp/>at<sp/>the<sp/>front</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!hasContiguousSubspace(indices))<sp/>{</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/>std::tie(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>indices)<sp/>=<sp/>transposeToFront(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>indices);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>linearIndex<sp/>=<sp/>computeLinearIndex(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>indices);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_tuple(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>linearIndex);</highlight></codeline>
<codeline lineno="250"><highlight class="normal">}</highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight></codeline>
<codeline lineno="252"><highlight class="normal">Tensor<sp/>index(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>TensorList<sp/>indices)<sp/>{</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(indices.size()<sp/>&gt;<sp/>(size_t)</highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim())<sp/>{</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/>AT_ERROR(</highlight><highlight class="stringliteral">&quot;too<sp/>many<sp/>indices<sp/>for<sp/>tensor<sp/>of<sp/>dimension<sp/>&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim(),<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(got<sp/>&quot;</highlight><highlight class="normal">,<sp/>indices.size(),<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="256"><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/>Tensor<sp/>src,<sp/>linearIndex;</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/>std::tie(src,<sp/>linearIndex)<sp/>=<sp/>makeLinearIndex(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>indices);</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>src.take(linearIndex);</highlight></codeline>
<codeline lineno="260"><highlight class="normal">}</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal">Tensor<sp/>index_put(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>TensorList<sp/>indices,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>value)<sp/>{</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(indices.size()<sp/>&gt;<sp/>(size_t)</highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim())<sp/>{</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/>AT_ERROR(</highlight><highlight class="stringliteral">&quot;too<sp/>many<sp/>indices<sp/>for<sp/>tensor<sp/>of<sp/>dimension<sp/>&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim(),<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(got<sp/>&quot;</highlight><highlight class="normal">,<sp/>indices.size(),<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/>Tensor<sp/>src,<sp/>linearIndex,<sp/>expandedValue;</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/>std::tie(src,<sp/>linearIndex)<sp/>=<sp/>makeLinearIndex(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>indices);</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/>std::tie(expandedValue)<sp/>=<sp/>expand_inplace(linearIndex,<sp/>value);</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/>Tensor<sp/>dst<sp/>=<sp/>src.clone();</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>dst.put_(linearIndex,<sp/>expandedValue);</highlight></codeline>
<codeline lineno="272"><highlight class="normal">}</highlight></codeline>
<codeline lineno="273"><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal">Tensor<sp/>&amp;<sp/>index_put_(Tensor<sp/>&amp;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>TensorList<sp/>indices,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>value)<sp/>{</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(indices.size()<sp/>&gt;<sp/>(size_t)</highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim())<sp/>{</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/>AT_ERROR(</highlight><highlight class="stringliteral">&quot;too<sp/>many<sp/>indices<sp/>for<sp/>tensor<sp/>of<sp/>dimension<sp/>&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim(),<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(got<sp/>&quot;</highlight><highlight class="normal">,<sp/>indices.size(),<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/>Tensor<sp/>src,<sp/>linearIndex,<sp/>expandedValue;</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/>std::tie(src,<sp/>linearIndex)<sp/>=<sp/>makeLinearIndex(</highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>indices);</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/>std::tie(expandedValue)<sp/>=<sp/>expand_inplace(linearIndex,<sp/>value);</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>src.put_(linearIndex,<sp/>expandedValue);</highlight></codeline>
<codeline lineno="283"><highlight class="normal">}</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal">Tensor<sp/>&amp;<sp/>index_copy_(Tensor<sp/>&amp;<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">,<sp/>int64_t<sp/>dim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tensor<sp/>&amp;<sp/>source)<sp/>{</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/>dim<sp/>=<sp/>maybe_wrap_dim(dim,<sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.dim());</highlight></codeline>
<codeline lineno="287"><highlight class="normal"></highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index.dim()<sp/>&gt;=<sp/>2)<sp/>{</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/>AT_ERROR(</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;index_copy_():<sp/>Index<sp/>should<sp/>have<sp/>dimension<sp/>1<sp/>or<sp/>0<sp/>(got<sp/>&quot;</highlight><highlight class="normal">,<sp/>index.dim(),<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/>int64_t<sp/>numIndices<sp/>=<sp/>index.numel();</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(source.dim()<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>numIndices<sp/>!=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/>AT_ERROR(</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;index_copy_():<sp/>When<sp/>source<sp/>is<sp/>scalar,<sp/>index<sp/>should<sp/>have<sp/>one<sp/>element<sp/>(got<sp/>&quot;</highlight><highlight class="normal">,<sp/>numIndices,<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index.type().scalarType()<sp/>!=<sp/>ScalarType::Long)<sp/>{</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/>AT_ERROR(</highlight><highlight class="stringliteral">&quot;index_copy_():<sp/>Expected<sp/>LongTensor<sp/>for<sp/>index&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>source<sp/>and<sp/>destination<sp/>slices<sp/>have<sp/>the<sp/>same<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>selfSlicedSizes<sp/>=<sp/>std::vector&lt;int64_t&gt;(</highlight><highlight class="keyword">self</highlight><highlight class="normal">.sizes());</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(selfSlicedSizes.size()<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/>selfSlicedSizes.erase(selfSlicedSizes.begin()<sp/>+<sp/>dim);</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sourceSlicedSizes<sp/>=<sp/>std::vector&lt;int64_t&gt;(source.sizes());</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sourceSlicedSizes.size()<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/>sourceSlicedSizes.erase(sourceSlicedSizes.begin()<sp/>+<sp/>dim);</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(selfSlicedSizes.size()<sp/>!=<sp/>sourceSlicedSizes.size()<sp/>||</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>!std::equal(selfSlicedSizes.begin(),<sp/>selfSlicedSizes.end(),</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sourceSlicedSizes.begin()))<sp/>{</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/>std::stringstream<sp/>ss;</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/>ss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;index_copy_():<sp/>Source/destination<sp/>tensor<sp/>must<sp/>have<sp/>same<sp/>slice<sp/>shapes.<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/>ss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Destination<sp/>slice<sp/>shape:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>selfSlicedSizes<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>dimension<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dim;</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/>ss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>source<sp/>slice<sp/>shape:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>sourceSlicedSizes<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>dimension<sp/>0.&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(ss.str());</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(source.dim()<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>numIndices<sp/>!=<sp/>source.size(dim))<sp/>{</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>AT_ERROR(</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;index_copy_():<sp/>Number<sp/>of<sp/>indices<sp/>(&quot;</highlight><highlight class="normal">,<sp/>numIndices,<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>should<sp/>be<sp/>equal<sp/>to<sp/>source.size(dim)<sp/>(&quot;</highlight><highlight class="normal">,<sp/>source.size(dim),<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">._indexCopy_(dim,<sp/>index,<sp/>source);</highlight></codeline>
<codeline lineno="325"><highlight class="normal">}</highlight></codeline>
<codeline lineno="326"><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal">}}<sp/></highlight><highlight class="comment">//<sp/>at::native</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/Users/robkunkle/fork/goodlux/pytorch/aten/src/ATen/native/Indexing.cpp"/>
  </compounddef>
</doxygen>
